# Getting Started (Conceptual Exercises and Solutions)

## Insertion Sort

**2.1-1**

Illustrate the operation of `INSERTION-SORT` on the array A = <31, 41, 59, 26, 41, 58>.

> The numbers in bold will indicate the position of the key and the italics will show the numbers against which the key will be compared.

A = [*31*, *41*, *59*, **26**, 41, 58]

A = [26, 31, *41*, *59*, **41**, 58]

A = [26, 31, 41, 41, *59*, **58**]

A = [26, 31, 41, 41, 58, 59]

**2.1-2**

Rewrite the `INSERTION-SORT` procedure to sort into non-increasing instead of non-decreasing order.

> We just invert the key check with the previous elements.

```pascal
for i = 2 to length(A)
    do key = A[i]
    //Insert A[i] in sorted sequence A[i .. i - 1]
       j = i - 1
       while j > 0 and A[j] < key
       do A[j + 1] = A[j]
          j = j - 1
       A[j + 1] = key
```

**2.1-3**

Consider the _**searching problem**_:

**Input**: A sequence of `n` numbers `A = a1,a2,...,an` and a value `v`.

**Output**: An index `i` such that `v = A[i]` or the special value `NIL` if `v` does not appear in `A`.

Write pseudocode for **linear search**, which scans through the sequence, looking for `v`. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

```pascal
for i = 1 to length(A)
   if A[i] == v
      return i

return NIL
```

> Initialization: The subarray is empty and hence doesn't contain v.
>
> Maintenance: For every iteration, if `A[i]` equals `v`, we move to termination, or we go back to initialization with a different subarray.
>
> The loop terminates when we find `v` or when we reach end of loop.

**2.1-4**

Consider the problem of adding two n-bit binary integers, stored in two n-element arrays A and B. The sum of the two integers should be stored in binary form in an (n + 1)-element array C. State the problem formally and write pseudocode for adding the two integers.

> **Input**: Two n-bit [a1, a2,..., an], [b1, b2,..., bn] which are binary representations of A and B.
>
> **Output**: One n+1-bit [c1, c2,..., cn] which is a binary representation of C : C = A + B.

```pascal
for i = 1 to length(A) + 1
   do C[i] = 0

next = 0

for i = length(A) to 1
   do next = (A[i] + B[i] + C[i])
      C[i] = next % 2
      C[i + 1] = next / 2
```

---

## Analyzing Algorithms

**2.2-1**

Express the function $n^3/1000 − 100n^2 − 100n + 3$ in terms of $\Theta$-notation.

> $n^3/1000 − 100n^2 − 100n + 3 \approx n^3/n^2 = \Theta(n)$

**2.2-2**

Consider sorting `n` numbers stored in array `A` by first finding the smallest element of `A` and exchanging it with the element in `A[1]`. Then find the second smallest element of `A`, and exchange it with `A[2]`. Continue in this manner for the first `n − 1` elements of `A`. Write pseudocode for this algorithm, which is known as **_selection sort_**. What loop invariant does this algorithm maintain? Why does it need to run for only the first `n − 1` elements, rather than for all `n` elements? Give the best-case and worst-case running times of selection sort in -notation.

```pascal
for i = 1 to length(A) - 1
   do key = i
      for j = i + 1 to length(A)
         if A[j] = A[key]
            do key = j
      temp = A[key]
      A[key] = A[i]
      A[i] = temp
```

> The loop invariant that is maintained is that for every iteration `i`, the subarray `A[1,..., i - 1]` will be sorted in increasing order.
>
> From the above loop invariant, at the n<sup>th</sup> iteration, `A[1,..., n - 1]` is already sorted **into its place** implying that the element in the last place needn't be sorted.
>
>
> Irrespective of the input, the algorithm performs checks on every key against the other keys, therefore:
>
> Best-case running time: $\Theta(n^2)$ \
> Worst-case running time: $\Theta(n^2)$

**2.2-3**

Consider linear search again (see Exercise 2.1-3). How many elements of the input sequence need to be checked on the average, assuming that the element being searched for is equally likely to be any element in the array? How about in the worst case? What are the average-case and worst-case running times of linear search in $\Theta$-notation? Justify your answers.

> On average, n/2 inputs need to be checked and in the worst case, all n inputs need to searched. The worst case scenario is pretty straightforward. On average means that we fill up the array with n random numbers, in which case there will probably be an equal number of keys which are greater and smaller than our number i.e, our number will be right in the middle on average. **Note that the text also states that it isn't easy to specify what the average means in general while doing analysis**.
>
> It follows from the above explanation that both average and worst case running times are $\Theta(n).$

**2.2-4**

How can we modify almost any algorithm to have a good best-case running time?

> One thing we can do is to remove loops, this usually means that instead of checking every key. We just check whether the input is a special case.
>
> For example, for any sort, you can make best case $\Theta(n)$ by checking if the array is already sorted - and if it is, return it as it is.
---

## Designing Algorithms