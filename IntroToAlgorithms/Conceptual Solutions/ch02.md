# Getting Started (Conceptual Exercises and Solutions)

## Insertion Sort

**2.1-1**

Illustrate the operation of `INSERTION-SORT` on the array A = <31, 41, 59, 26, 41, 58>.

> The numbers in bold will indicate the position of the key and the italics will show the numbers against which the key will be compared.

A = [*31*, *41*, *59*, **26**, 41, 58]

A = [26, 31, *41*, *59*, **41**, 58]

A = [26, 31, 41, 41, *59*, **58**]

A = [26, 31, 41, 41, 58, 59]

**2.1-2**

Rewrite the `INSERTION-SORT` procedure to sort into non-increasing instead of non-decreasing order.

> We just invert the key check with the previous elements.

```pascal
for i = 2 to length(A)
    do key = A[i]
    //Insert A[i] in sorted sequence A[i .. i - 1]
       j = i - 1
       while j > 0 and A[j] < key
       do A[j + 1] = A[j]
          j = j - 1
       A[j + 1] = key
```

**2.1-3**

Consider the _**searching problem**_:

**Input**: A sequence of `n` numbers `A = a1,a2,...,an` and a value `v`.

**Output**: An index `i` such that `v = A[i]` or the special value `NIL` if `v` does not appear in `A`.

Write pseudocode for **linear search**, which scans through the sequence, looking for `v`. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

```pascal
for i = 1 to length(A)
   if A[i] == v
      return i

return NIL
```

> Initialization: The subarray is empty and hence doesn't contain v.
>
> Maintenance: For every iteration, if `A[i]` equals `v`, we move to termination, or we go back to initialization with a different subarray.
>
> The loop terminates when we find `v` or when we reach end of loop.

**2.1-4**

Consider the problem of adding two n-bit binary integers, stored in two n-element arrays A and B. The sum of the two integers should be stored in binary form in an (n + 1)-element array C. State the problem formally and write pseudocode for adding the two integers.

> **Input**: Two n-bit [a1, a2,..., an], [b1, b2,..., bn] which are binary representations of A and B.
>
> **Output**: One n+1-bit [c1, c2,..., cn] which is a binary representation of C : C = A + B.

```pascal
for i = 1 to length(A) + 1
   do C[i] = 0

next = 0

for i = length(A) to 1
   do next = (A[i] + B[i] + C[i])
      C[i] = next % 2
      C[i + 1] = next / 2
```